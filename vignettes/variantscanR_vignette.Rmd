---
title: "_variantscanR_ vignette"
author: "Fréderique Boeykens"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{variantscanR vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
# Introduction

One of the main goals in the genetics field is the identification of genetic variation accountable for a
certain phenotype. This goal has been facilitated for several years by the introduction of next-generation
sequencing technologies. At present time, most of the tools available for the evaluation of whole-genome
or exome sequencing (WGS and WES, respectively) data are solely applicable for human analysis. For this
reason, we developed _variantscanR_, an _R-package_, for the easy and straightforward identification of known
disease-causing variants from a large collection of variants present in dogs and other animals.

The R-package variantscanR enables the filtering of variant call format (VCF file) files for the presence
of known disease-causing variants. In addition to the main variant-filtering function, the package allows
for the estimation of genetic diversity using both single and multisample VCF files. User-defined, file
format-specific options are available for the quality control of certain parameters using online database
screening. Finally, next to the filtering of known disease-causing variants, an additional step is
optional to gather the remaining variants located within the genes of interest. 

VariantscanR is an R package, designed for the use as a clinical tool for variant filtering of known
disease-causing mutations in domestic animals. The package focuses on cats and dogs but can be used for
every animal if the required data and information for this animal is present. 

This vignette is divided into four parts:

* Preprocessing
* Variant filtering
* Diversity
* Extra

A visual representation of the workflow is given below.
To explain the workflow of this package, an example will be used and elaborated in this vignette.
Disclaimer: Not the entire VCF dataset is used for as this is a very large file.

![variantscanR workflow](https://raw.githubusercontent.com/FrederiqueBoeykens/images/main/workflow.png)


**Example: Labrador retriever**

WES data were obtained from 16 different dogs for an independent project at the laboratory. 
The data used in this vignette is for purely demonstrative purposes. 
One sample, from here on referred to as sample_849, was chosen randomly out of the pool of 16 dogs and is
a yellow, female Labrador retriever. 


# Preprocessing
For the filtering of variants, the pipeline needs a least 3 different input file. The first one being the
file containing the variants of interest. Secondly, the VCF file to which the variants of interest need to
be filtered is required and thirdly, a BED file for the annotation of found variants is needed throughout
the worflow. These 3 files require a certain format, which is explained in the following sections.

## Input files
### (1) VCF file
VCF stands for 'Variant Call Format' and is a standardized text file format used for reporting SNPs, indel and structural variations. A VCF file is composed of 3 main parts: 

* Meta-data, starting with '##'
* A header that starts with '#CHROM'
* Variant call records

The first 9 columns of the header line and the variant call record line give information on the variants found.

The VCF file already has a certain fixed format and don't need adjusting. In fact, **never edit** a VCF in a word processor by hand, because it **will** screw up the format! 

### (2) Variants file
The variants file contains the known disease-causing variants you are interested in. This file does need a certain format so it can be used in downstream analysis. 
Following columns need to be specified:

* __Chromosome__
* __Start__
* End
* Reference
* Reference sequence
* Inheritance pattern
* __Gene__
* Variant Phenotype
* Breed

The columns in __bold__ are mandatory, the other ones are optional. The optional columns need to be included in the file, but don't need values, so _NA_ values are allowed. 

However, the function also allows another 'specific' format that can be downloaded straight from the internet, to make it a little more user-friendly. 
The file can be downloaded from [here](https://www.omia.org/home/). For example, if you want to download the known-disease causing variants of the dog, a CSV document can be obtained from [here](https://www.omia.org/results/?gb_species_id=9615&search_type=advanced&result_type=variant) at the bottom __'Download table as CSV'__.
When the CSV file is converted into an Excel table, you will notice that the _Start_, _End_ and _Reference sequence_ columns are replaced by a _'g. or m.'_ column. The package allows this format. However, in the _pRocess_ function (explained below), the OMIA parameter has to be set to TRUE (default = FALSE). 

### (3) BED file
A BED (Browser Extensible Data) file is needed for annotation along the way. A BED file had a fixed format, including 3 required fields:

* chrom
* chromStart
* chromEnd

and 9 additional optional BED fields:

* name
* score
* strand
* thickStart
* thickEnd
* itemRgb
* blockCount
* blockSizes
* blockStarts

Such a BED file can be downloaded [here](http://genome.ucsc.edu/cgi-bin/hgTables) at __the UCSC table Browser__. For our example, we need a BED file for the dog. In our example following criteria were chosen:

* clade: Mammal
* genome: Dog
* assembly: Sep. 2011 (Broad CanFam3.1/canFam3) (*)
* group: Genes and Gene predictions
* track: NCBI RefSeq (*)
* table: RefSeq All (ncbiRefSeq)
* region: genome
* output format: BED - browser extensible data
* output filename: dog_BED_NCBI (*)

(*) These criteria were specifically chosen for this example. Assembly versions change over time and obviously are updated. The assembly you choose should be the same version as the assembly used to create/map the variants in your variants file. Next to _NCBI RefSeq_, you can also choose _Ensembl Genes_. The output file can be found in the package [Data folder](https://github.com/FrederiqueBoeykens/variantscanR/tree/main/data). 

However, this BED file itself needs some extra annotation. For this reason yet another file needs to be
downloaded from the same [site](http://genome.ucsc.edu/cgi-bin/hgTables). The same criteria apply for
this file as the previous BED file, except for the output format. Instead of chosing _BED - browser extensible data_, _all fields from selected table_ is required. 

And that was it! Now you are ready to do some variant filtering!

### (Extra) Chromosome names table
Next, depending on the reference genomes used for creating the VCF file, the chromosome notation can have
different denominations. The _chromosomenameR_ function allows the conversion, if needed. The chromosomes
have multiple different nomenclatures depending on the reference used for mapping. For example, in dogs,
chromosome 1 can be noted as CM000001.3 or NC_006583.3, using the GenBank or RefSeq sequence,
respectively. This notation needs to be changed to the ‘chrN’ notation, with N being the number of the
chromosome. This is done using the _chromosomerenamR_ function.

For this conversion a file a needed providing both names. For the dog, such a file is available in the package [Data folder](https://github.com/FrederiqueBoeykens/variantscanR/tree/main/data). 
The original names are stored in the first column and the 'chrN' names are placed in the second column.

## _VCFscanneR_
Because the VCF file format is not one of the standard formats that can be uploaded in the R environment, the vcfscannR function was created.
This function uploads a multisample sample VCF file into the R environment and turns it into a single
sample VCF, ready for downstream analysis. 
The function has 2 parameters. The first parameter is the name of the VCF file that needs to be uploaded
OR contains the path to the file. The second parameter is the name of the sample of interest. The sample
name has to match with that of the VCF file. In our example, the name is _sample_849_. 

NEED ORIGINAL SUBSET VCF FILE!!!

The example VCF file (_subset_vcf_multisample_) has 31 rows and 10 columns and contains variants found within chromosome 5. 

```{r, echo=FALSE}
vcfscanneR <- function(x, sample){
  vcf <- vcfR::read.vcfR(x)
  fix <- vcf@fix
  fix <- as.data.frame(fix, stringsAsFactors = FALSE)
  gt <- vcf@gt
  gt <- as.data.frame(gt, stringsAsFactors = FALSE)
  fix <- cbind(fix, gt[,1])
  names(fix)[9] <- "FORMAT"
  gt <- gt %>% dplyr::select(dplyr::all_of(sample))
  vcf <- cbind.data.frame(fix,gt)
  vcf_names <- c("chrom", "pos", "id", "ref", "alt", "qual", "filter", "info", "format", "sample")
  names(vcf) <- vcf_names
  return(vcf)
}
```

After uploading the multisample VCF file with _vcfscanneR_ function, the VCF looks like this:

```{r}
data(subset_vcf_multisample, package = "variantscanR")
# VCF file subset dimentions
dim(subset_vcf_multisample)
# VCF file first 10 rows
head(subset_vcf_multisample)
```

As you can see, the chromosomes do not have the required 'chrN' notation, for this the _chromosomenameR_ function needs to be carried out.

## _chromosomenameR_

```{r, echo=FALSE}
chromosomenameR <- function(a,b){
  new <- a
  new[] <- lapply(a, function(x) b[,2][match(x, b[,1])])
  a[,1] <- new[,1]
  a[] <- lapply(a, as.character)
  return(a)
}
```

```{r}
data("dog_chromosome_names", package = "variantscanR")
a <- subset_vcf_multisample
b <- dog_chromosome_names
vcf <- chromosomenameR(a,b)
head(vcf)
```

Now, our VCF file is ready for variant filtering. 

## _annotateR_NCBI.R_
As was explained in the input section above, the BED file itself needs anotating. For this step, 2 separate functions were created that essentially do the same thing. One function can be used for a _NCBI RefSeq_ BED file. Whereas the other function was designed to handle an _Ensemble Genes_ (see section 'input file').

For demonstrative purposes, only the NCBI specific function, _annotateR_NCBI_ function will be demonstrated for as the BED file used in this example is _NCBI RefSeq_ based.

```{r, echo=FALSE}
annotateR_NCBI <- function(a, b){
  a[] <- lapply(a, as.character)
  b[] <- lapply(b, as.character)
  refseq_transcripts <- a[,4]
  BED <- a
  new <- BED
  new[] <- lapply(BED, function(x) b$name2[match(x, b$name)])
  BED[,4] <- new[,4]
  BED[] <- lapply(BED, as.character)
  BED[,13] <- refseq_transcripts
  BED <- BED[complete.cases(BED[,4]),]
}
```

This is what the NCBI based BED file looks like:

```{r}
data("dog_BED_NCBI", package = "variantscanR")
head(dog_BED_NCBI)
```

You can see that the 3 required and the 9 additional fields are present.
Now let's annotate this file with the second file we downloaded from UCSC table browser.

```{r}
data("dog_BED_NCBI", package = "variantscanR")
data("dog_allfields_NCBI", package = "variantscanR")
a <- dog_BED_NCBI
b <- dog_allfields_NCBI
BED_file_fully_annotated <- annotateR_NCBI(a,b)
head(BED_file_fully_annotated)
```

A 13th column (V13) is added, containing the gene names instead of just the transcripts that are present in the BED file with 12 columns. This is important because _the variants file_ only contains gene names and not transcript names.

__NOTE__: The entire workflow has been performed on the same dataset using the same _variants file_ for both the _NCBI refseq_ BED file and the _Ensembl genes_ BED file. It was noticed that overall less variants were attained after filtering with the  _Ensembl genes_ BED file compared to the _NCBI refseq_ BED file. This is mostly due to different annotation of the reference sequence and that less gene names were present/annotated in the _Ensembl genes_ BED file.

## _pRocess_
Now that all the input files have been amended for downstream analysis. A final preprocessing step, that is a mandatory in the pipeline, can be performed. 

The _pRocess_ function has several parameters of which a couple are optional.
Because files that are manually made or adjusted are prone to human errors, quality control might be useful. The _pRocess_ function includes some optional quality control filters. 
For example, the genomic locations provided for each variants are screened for errors by comparison with a reference genome. If a mismatch is encountered, the user will get notified if this error and will be asked to check this information for this variant.
Next to this, an assembly version check can be performed by providing the "refseq" parameter with this information. If a variant does not belong to the right verion, that variant is removed from the VCF file. This is _"CanFam3.1"_ in our example. 
If the _variants file_ is downloaded from the OMIA website (as explained above in the Input files section), it is possible to provide the function with this information by setting the _OMIA paramater_ to TRUE (this is FALSE by default). 

In summary, we have 6 parameters:
1. variants_file: _Required_
2. BED_file: _Required_
3. refseq: _Optional_ and is TRUE by default
4. QC: _Optional_
5. organism: _Optional_ but _Required_ if QC = TRUE
6. OMIA: _Optional_ and is FALSE by default





```{r, echo=FALSE}
pRocess <- function(variants_file, BED_file, refseq, QC = TRUE, organism = NULL, OMIA = FALSE){
  if (OMIA == TRUE){
    variants_file <- variants_file[stats::complete.cases(variants_file[1]), ]
    colnames(variants_file)[1] <- "Chr."
    variants_file <- variants_file[stats::complete.cases(variants_file[2]), ]
    colnames(variants_file)[2] <- "g. or m"
    colnames(variants_file)[3] <- "Reference Sequence"
  } else {
    variants_file <- variants_file[stats::complete.cases(variants_file[1]), ]
    colnames(variants_file)[1] <- "Chromosome"
    variants_file <- variants_file[stats::complete.cases(variants_file[2]), ]
    colnames(variants_file)[2] <- "Start"
    colnames(variants_file)[3] <- "End"
    colnames(variants_file)[4] <- "Reference"
    colnames(variants_file)[5] <- "Reference Sequence"
  }
  for (r in 1:nrow(variants_file)){
    if (OMIA == TRUE){
      id <- variants_file[r,3]
      id <- gsub(" ", "", id) #remove potential spaces between CanFam and 3.1 so we can filter them out in next step
    } else {
      id <- variants_file[r,5]
      id <- gsub(" ", "", id) #remove potential spaces between CanFam and 3.1 so we can filter them out in next step
    }
  }
  if (missing(refseq)){
    variants_file <- variants_file
  } else {
    variants_file <- subset(variants_file, variants_file$'Reference Sequence'== refseq )
  }
  if (OMIA == TRUE){
    between <- variants_file
    for (r in 1:nrow(between)){
      original <- between[r,2]
      original <- gsub(",","", original)
      original <- gsub(">", "", original)
      original <- gsub("_", "-", original)
      between[r,2] <- original
    }
    final <- data.frame()
    for (r in 1:nrow(between)){
      output = NULL
      row <- between[r,]
      nrc <- ncol(between)
      id <- between[r,2]
      id <- stringr::str_split(id, pattern = ("-"), n = 2, simplify = TRUE)
      start_pos <- id[1,1]
      end_pos <- id[1,2]
      output <- cbind(row[,1], start_pos, end_pos, row[,3:nrc])
      output_temp <- data.frame(output)
      final <- rbind(final, output_temp)
    }
    colnames(final)[1:4] <- c("Chromosome", "Start", "End", "Reference Sequence")
    final <- data.frame(lapply(final, as.character), stringsAsFactors = FALSE)
    for(r in 1:nrow(final)){
      pattern_loc_start <- rebus::optional(or("g","m")) %R% rebus::optional(DOT) %R% rebus::capture(one_or_more(DGT)) %R% rebus::optional(WRD)
      pattern_loc_end <- rebus::capture(one_or_more(DGT)) %R% rebus::optional(WRD) %R% rebus::optional(one_or_more(DGT))
      start <- stringr::str_match(final[r,2], pattern = pattern_loc_start)
      end <- stringr::str_match(final[r,3], pattern = pattern_loc_end)
      final[r,2] <- start[,2]
      final[r,3] <- end[,2]
    }
    for (r in 1:nrow(variants_file)){
      original <- as.character(variants_file[r,2])
      original <- gsub(",","", original)
      original <- gsub("_", "", original)
      original <- gsub("g.", "", original)
      original <- gsub("m.", "", original)
      original <- gsub("[0-9]", "", original)
      original <- gsub("del", "", original)
      original <- gsub("dup", "", original)
      original <- gsub("inv", "", original)
      original <- gsub("ins", "", original)
      if (grepl(">", original, fixed = TRUE)){
        pattern <- rebus::capture(or("T", "A", "C", "G")) %R% ">" %R% or("T", "A", "C", "G")
        nt <- stringr::str_match(original, pattern = pattern)
        original <- nt[1,2]
      } else {
        original <- original
      }
      variants_file[r,2] <- original
    }
    final$Chromosome <- paste0("chr", final$Chromosome)
    nrccc <- ncol(final)
    final <- cbind(final[,1:3], variants_file[,2], final[,4:nrccc])
    colnames(final)[4] <- "Reference"
  } else {
    final <- variants_file
    final$Chromosome <- paste0("chr", final$Chromosome)
  }
  if (QC == TRUE){ #until now everything was the same for QC = TRUE or FALSE
    random1 <- data.frame()
    for (r in 1:nrow(final)){
      row <- final[r,]
      nrcc <- ncol(final)
      a <- final[r,1]
      b <- as.numeric(final[r,2])
      c <- as.numeric(final[r,3])
      c[is.na(c)] <- b
      Check <- Biostrings::getSeq(organism, a, start = b, end = c)
      Check <- as.character(Check)
      random <- cbind(row[,1:4], Check, row[,5:nrcc], row.names = NULL)
      random2 <- data.frame(random)
      random1 <- rbind(random1, random2)
    }
    test <- unique(random1)
    proc_variants_file <- data.frame()
    for (r in 1:nrow(test)){
      end <- ncol(test)
      row <- test[r,]
      gene <- test[r,8]
      index <- which(BED_file$V4 == gene) #gene name
      orientation <- BED_file[index,6]    #orientatio + or -
      orientation <- as.character(orientation)
      if (length(unique(orientation)) == 1){
        orientation <- orientation[1]
      } else {
        orientation <- "Information lacking"
      }
      proc_variants_file1 <- cbind(row[,1:5], orientation, row[,6:end], row.names = NULL)
      proc_variants_file2 <- data.frame(proc_variants_file1)
      proc_variants_file <- rbind(proc_variants_file, proc_variants_file2)
    }
    proc_variants_file <- data.frame(lapply(proc_variants_file, as.character), stringsAsFactors = FALSE)
    for (r in 1:nrow(proc_variants_file)){
      if (proc_variants_file[r,6] == "-") {
        dna <- proc_variants_file[r,5]
        dna <- Biostrings::DNAString(dna)
        dna <- Biostrings::reverseComplement(dna)
        dna <- as.character(dna)
        proc_variants_file[r,5] <- dna
      } else if (proc_variants_file[r,6] == "+"){
        dna <- proc_variants_file[r,5]
        proc_variants_file[r,5] <- dna
      } else {
        dna <- "Check manually"
        proc_variants_file[r,5] <- dna
      }
    }
    proc_variants_file[is.na(proc_variants_file)] <- "NA"
    for (r in 1:nrow(proc_variants_file)){
      if(proc_variants_file[r,4] == proc_variants_file[r,5]){
        proc_variants_file[r,5] <- proc_variants_file[r,5]
      } else {
        proc_variants_file[r,5] <- "Check manually"
      }
    }
  } else {proc_variants_file <- final}
  return(proc_variants_file)
}
```

```{r, echo=FALSE, message= FALSE}
library(BSgenome)
library(BSgenome.Cfamiliaris.UCSC.canFam3)
library(rebus)
library(tibble)
```


#### test 1: Quality control; OMIA = TRUE and QC = TRUE
```{r}
data("variants_file_OMIA_dog", package = "variantscanR")
variants_file <- variants_file_OMIA_dog
BED_file <- BED_file_fully_annotated
refseq <- "CanFam3.1"
organism <- BSgenome.Cfamiliaris.UCSC.canFam3
variant_file_processed <- pRocess(variants_file, BED_file, refseq, QC = TRUE, organism, OMIA = TRUE)
head(variant_file_processed)
```


This shows a good example of the quality control that is performed on the location of the variants. For the first SNP located on chromosome 6 at location 55146549, the user-defined _variants_file_ states that a C is should be present at that location. However, when comparing with an online Reference Sequence, no match is found. The output tells the user to double check the information on this variant. When looking up this variant on OMIA.org, from where the file was downloaded, it shows that it is an insertion of C on that location, which explains why it did not match the reference. For as all the other information was correct, it won't cause any problems for downstream analysis. 
For the 5th variant, no reference was given and thereforethat row needs revisioning. 


#### test 2: No quality control; OMIA = TRUE and QC = FALSE
#### test 3: No refseq given; OMIA = TRUE and QC = TRUE
#### test 4: Other format provided, OMIA = FALSE, QC = TRUE


# Variant filtering
After the preprocessing step are done, the filtering step can be performed. 

## _variantfiltR_
HERE NEEDS TO COME THE FUNCTION AND THE EXAMPLE R CODE

## Reporting
For demonstrative purposes, not the entire VCF dataset was used for the worked out example in this vignette. However, we do believe it is important to work out a real example using the entire dataset and show the outcome. For this reason, images were made of the real outcome and are shown below. 

So if we go through the entire pipeline, after the _variantfiltR_ function, an html report is created. The minimal output is an interactive overview of the various table created after filtering (fig2). By clicking on the desired table, the output will be displayed.


![Figure 2: Report overview of tables](https://raw.githubusercontent.com/FrederiqueBoeykens/images/main/1_report_overview.jpg)

Next to this, breeding advice is also provided for heterozygous (fig3) and homozygous (fig4) variants according to the inheritance pattern.


![Figure 3: Heterozygous breeding advice](https://raw.githubusercontent.com/FrederiqueBoeykens/images/main/5_BA_heterozygous.jpg)


![Figure 4: Homozygous breeding advice](https://raw.githubusercontent.com/FrederiqueBoeykens/images/main/6_BA_homozygous.jpg)

Finally, if a breed is provided as a parameter in the _variantfiltR_ function, 3 other tables are acquired. One table containes the most important variants, being the variants that are not homozygous wild type AND are found within the breed of interest. Because known-disease causing variants are checked within the animal of interest, these variants might be important for health and diagnostics. (fig5). 


![Figure 5](https://raw.githubusercontent.com/FrederiqueBoeykens/images/main/1_report_most_important.jpg)


The second table contains variants that are not homozygous wild type but are not known to have implications in or known to occur in the breed of interest. Still, this kind of information might be important to report (fig6). 


![Figure 6](https://raw.githubusercontent.com/FrederiqueBoeykens/images/main/3_report_not_breed.jpg)


Lastly, the third table contain the variants found or not found within the breed of interest that are homozygous wild type (fig7). 


![Figure 7](https://raw.githubusercontent.com/FrederiqueBoeykens/images/main/4_report_WT.jpg)



# Diversity
The _variantscanR_ package also features a diversity analysis. Although this is not an in-depth method to study diversity, it does offer many possibilities. 


## diveRsity
The input is a multisample VCF file and the name of one specific sample the user is interested in. 

NEEDS THE DATASET!!

Most of the output of the _diveRsity_ function are graphs, however, also a table with the actual diversity values is given. 
The level of heterozygosity is calculated as followed:


$H_{e} = \displaystyle \frac{n_{He}}{n_{n}}$


With $H_{e}$ being the level of heterozygosity, $n_{He}$ the number of heterozygous loci in the sample of interest and $n_{n}$, the total number of loci used. $n_{n}$ is the same for every sample of the multisample VCF file. 



## Reporting
As with the _variantfiltR_ function, the not the entire VCF dataset was used in the worked-out example for the _diveRsity_ function. However, the graphs of the real example are displayed below.

The first graph gives a basic overview of all the samples included in the multi-sample VCF file. The level of heterozygosity is shown on the y-axis and the x-axis displays the different breeds present.


![Figure 8: Basic overview](https://raw.githubusercontent.com/FrederiqueBoeykens/images/main/Diversity2.jpg)


The second graph reveals the name of every sample.


![Figure 9: fully annotated](https://raw.githubusercontent.com/FrederiqueBoeykens/images/main/Diversity3.jpg)


The third graph only reveals the name of the sample of interest, that was provided as a parameter to the _diveRsity_ function.



![Figure 10](https://raw.githubusercontent.com/FrederiqueBoeykens/images/main/Diversity5.jpg)


Lastly, the fourth graph only shows the highest sample of every breed.


![Figure 11](https://raw.githubusercontent.com/FrederiqueBoeykens/images/main/Diversity6.jpg)


Next to the graphs, a table is included in the output of the _diveRstity_ function, containing the heterozygosity values per sample.


![Figure 12](https://raw.githubusercontent.com/FrederiqueBoeykens/images/main/Diversity1.jpg)


# Extra










